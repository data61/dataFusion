# dataFusion-common
## Introduction
Common [Scala](http://scala-lang.org/) code shared by the other Scala sub-projects.

This module provides:
- shared JSON data structures; and
- a simple parallel processing framework used by all dataFusion’s multi-threaded CLI’s.

## Parallel Processing Framework
The parallel processing framework provides the following:

- an input queue of items of some type I;
- an output queue of items of some type O;
- an input [thread](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html) that generates I's, keeping the input queue as full as it can;
- a number of worker threads (generally equal to the number of CPUs), each independently taking an I from the input queue, performing useful work to produce an O and adding this to the output queue;
- an output thread that consumes O's, keeping the ouput queue as empty as it can.

Parameters to the framework are:

- the types I and O;
- the generator of I's, performing any input;
- the the work to be performed in parallel to the maximum extent possible, a transformation from I to O;
- the consumer of O's, performing any output.

All the dataFusion muti-threaded CLI’s operate by defining these parameters to suit the task at hand and using this framework.

## Build
See the top level README.

## JSON Data Formats
This section describes the JSON based data file formats used throughout the dataFusion project.
### File Structure
Each line is a JSON structure describing one item of some type. This is more efficient to read and write than making the entire file a JSON array of such structures, because parsing/serialisation can operate document/line at a time, without storing all the data in memory. Since the line delimiter is used as a structure delimiter, the JSON structures must not be “pretty printed” across multiple lines in the file, however “pretty printing” is used here as an aid to human readability.
### Document JSON format
This section describes the parsed representation of an unstructured document. A line in the file describes one document using the following structure.
#### Document Structure

    {
      "embedded": [],
      "path": "coReports/reports/0317-CMA-Annual-Report-2016-Aug16_Web.pdf",
      "id": 21,
      "meta": {
        "meta:creation-date": "2016-09-13T03:40:54Z",
        "dc:format": "application/pdf; version=1.5",
        …
       },
      "content": "text content”,
      "ner": []
    }

where:
- `embedded` will be elaborated below.
- `path` records the filesystem path (or perhaps URL if from read from a web server such as HDFS) where the document was read from.
- `id` is a unique numeric identifier for the document used across dataFusion (assigned incrementally by dataFusion-tika).
- `meta` is a metadata dictionary of key, value pairs; mostly extracted from the document, but some are generated by Tika depending on the document format; and our customization adds keys `language-code` and `language-prob` derived from analysis of the `content` field. `language-code` has value `en` for English and the value for `language-prob` is a numeric score representing confidence in the language determination. We also add a key `english-score` with a value from 0 to 1 to indicate how well the content matches a simple model of English sentences.
- `content` is the text content of the document. For an email message, Word document, Excel spreadsheet or born-digital PDF this is generally the exact text you would see in the application. For a scanned PDF this could be OCR text provided by the scanner software or otherwise blank.
- `ner` will be elaborated below. 

#### Embedded Document Structure
Many document formats, including Word, Excel, PDF and emails, support embedding other document formats. A Word document may contain multiple embedded images in a page and when converted to PDF, the PDF will contain the text of the document as well as the images. A scanned PDF contains at a minimum an embedded image of each scanned page. It may also contain text resulting from OCR at the time of scanning. Images are the most common form of embedded document, but a wide variety of formats can be embedded.

Each element in the `embedded` array is a structure representing one embedded document:

    {
      "content": "results of Tika/Tesseract OCR",
      "meta": {
        "tiff:BitsPerSample": "8 8 8 8",
        "Data PlanarConfiguration": "PixelInterleaved",
        …
      },
      "ner": []
    }

where fields have the same meaning as in the previous section.

#### NER Structure
The `ner` array is populated by NER processing methods (in the output from dataFusion-tika it is always an empty array). Each element is a structure representing one named entity mention:

    {
      "offStr": 3753,
      "offEnd": 3771,
      "posStr": 1542,
      "posEnd": 1544,
      "score": 0.9188285854330276,
      "text": "Nicholas Collishaw",
      "impl": "MITIE",
      "typ": "PERSON",
	"extRef": { … }
    }

where:
- `text` is the named entity mention.
- `impl` is the NER implementation that found the mention: the machine learning based methods: CoreNLP, OpenNLP or MITIE; or the information retrieval based method D61GAZ; or the pattern matching methods D61EMAIL and D61AGE.
- `score` is a measure of confidence provided by OpenNLP, MITIE and D61GAZ or 1 for CoreNLP, D61EMAIL and D61AGE.  Each implementation uses different confidence measure so the scores are not comparable across implementations.
- `typ` is the entity type: PERSON and ORGANIZATION are the main types of interest, but also recognized are: LOCATION; numerical values MONEY, NUMBER, ORDINAL, PERCENT; and temporal values DATE, TIME, DURATION; and the catch-all MISC. For impl=D61GAZ, PERSON2 is used to represent matches using only the family and first given names (with PERSON using the full name).
- `posStr` is the token (or loosely word) offset from the start of the “content” text to the first token/word of the  named entity mention. Tokenization may differ between the NER implementations so token offsets may not align exactly.
- `posEnd` is 1 + the token offset to the last token of the named entity mention.
- `offStr` is the character offset from the start of the “content” text to the first character of the named entity mention. This is independent of tokenization and is precisely comparable across all NER implementations.
- `offEnd` is 1 + the character offset to the last character of the named entity mention.
- `extRef` is optional and only present when impl=D61GAZ, or when impl=EMAIL and Ner.strPos matches a D61GAZ Ner from which the extRef is copied. This structure is described in the following section.
#### ExtRef Structure
This describes information from an external (with respect to DataFusion) data source e.g. the client register.

    {
      "name": "BIG CORP LIMITED",
      "ids": [2,501]
    }

where:
- `name` is the name generated from the external data source (and is what was searched for by dataFusion-search); and 
- `ids` are references to entities in the external data source with this name (e.g. for the client register this will be    `clnt_intrnl_id`s). 

### Search Result JSON format
This section describes the representation Search Results. A line in the file describes all the matches in all collections for a given entity name. Search results produced in this format are then merged into the Document JSON format described above using `dataFusion-util --hits`. It is recommended to use the merged Document JSON format data rather than the data in this format.
#### Search Result Structure
    {
      "stats": {
        "totalHits": 6,
        "elapsedSecs": 0.1290000081062317
      },
      "score": 9.504297256469727,
      "hits": [],
      "typ": "ORGANIZATION",
      "extRef": { … }
    }

where:
- `totalHits` is the number of elements in the hits array;
- `elapsedSecs` is the time taken for the search;
- `score` is a measure of the rarity of the search terms in the corpus. A high score reflects a low likelihood of a spurious match. It is an [IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf#Inverse_document_frequency) score  calculated using [Lucene’s formula](https://lucene.apache.org/core/7_1_0/core/org/apache/lucene/search/similarities/TFIDFSimilarity.html). 
- `hits` is an array of structures described in the following section;
- `typ` is ORGANIZATION, PERSON or PERSON2; and
- `extRef` is as described above.
#### Hit Structure
    {
      "idEmbIdx": {
        "id": 100,
        "embIdx": -1
      },
      "posInfos": []
    }

where:
- `id` refers to the document id in Document Structure;
- `embIdx` is -1 to refer to the main `content` or it is the index the `embedded` array element for embedded content: `embedded[embIdx].content`; and
- `posInfos` is an array of structures described in the following section.
 #### PosInfo Structure
        {
          "posStr": 4,
          "posEnd": 7,
          "offStr": 90,
          "offEnd": 108
        }

where fields have the same meaning as in NER Structure.

### PosQuery JSON format
The recommended method to generate queries for `dataFusion-search` is to let it generate the queries directly from a CSV data file, however it can also accept queries in the PosQuery JSON file format, with one PosQuery per line.
#### PosQuery Structure

    {
      "extRef": { … },
      "typ": "ORGANIZATION"
    }

where:
- `extRef` is as described in ExtRef Structure; and
- `typ` is as described in Search Result Structure.

### Node and Edge JSON formats
This section describes the network representation as a set of nodes in one file and a set of edges in another. Again there is one structure per line.
#### Node Structure

    {
      "nodeId": 521,
      "extRef": { … },
      "score": 9.50429725646972,
      "typ": "ORGANIZATION"
    }

where:
- `nodeId` is assigned incrementally to be unique only within the current network;
- `extRef` is as described in ExtRef Structure;
- `score` is as described in Search Result Structure; and
- `typ` is as described in NER Structure.
#### Edge Structure

    {
      "source": 521,
      "target": 12730,
      "weights": { "collection": [ weight, count ], … },
      "typ": "D61GAZ"
    }

where:
- `source` is the source nodeId;
- `target` is the target nodeId (graphs are undirected and source is always < target);
- `weights` is a map (or dictionary) with the collection name as the key mapped to a pair of values, which are the weight of the edge within the collection and the number of times this pair of nodes contribute to the weight (the number of co-occurrences within 5* the decay value) in the collection; and
- `typ` is the type of relationship (for the proximity network this is currently always D61GAZ).

